import React, { useState, useMemo, useEffect } from 'react';
import allowedAssignees from './data/allowedAssignees.json';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  PieChart,
  Pie,

  Cell,
  LineChart,
  Line,
} from 'recharts';
import {
  Upload,
  Users,
  TrendingUp,
  CheckCircle,
  Clock,
  AlertCircle,
  Calendar,
  Home,
} from 'lucide-react';
import { computeSuggestions, computeWhatIfProjection, computeSuggestionsDetailed, computeSprintProjectProgress } from './utils/allocation';

const SprintDashboard = () => {
  const [data, setData] = useState([]);
  const [selectedSprint, setSelectedSprint] = useState('all');
  const [selectedAssignee, setSelectedAssignee] = useState('all');
  const [sprintDates, setSprintDates] = useState({});
  const [assigneeCaps, setAssigneeCaps] = useState({});
  // Optional mapping of assignee -> Set of allowed project codes/names
  const [assigneeProjectMap, setAssigneeProjectMap] = useState({});
  const [projectAllowedMap, setProjectAllowedMap] = useState({});
  const [mappingLoadedCount, setMappingLoadedCount] = useState(0);
  const [mappingDiagnostics, setMappingDiagnostics] = useState([]);
  const [showMappingDiagnostics, setShowMappingDiagnostics] = useState(false);
  const [diagnosticRowAssignee, setDiagnosticRowAssignee] = useState({});
  const [showMergedDuplicates, setShowMergedDuplicates] = useState(false);
  const [suggestions, setSuggestions] = useState([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [suggestionRejections, setSuggestionRejections] = useState([]);
  const [whatIfMultiplier, setWhatIfMultiplier] = useState(1);
  const [jiraPreview, setJiraPreview] = useState([]);
  const [jiraPreviewVisible, setJiraPreviewVisible] = useState(false);
  const [jiraLog, setJiraLog] = useState([]);
  const [isApplying, setIsApplying] = useState(false);
  const [selectedSuggestionIds, setSelectedSuggestionIds] = useState([]);
  const [thresholds, setThresholds] = useState({ under: 0.7, over: 1 });
  // UI state for assignee ticket quick-actions
  const [assigneeTicketSelectedKeys, setAssigneeTicketSelectedKeys] = useState([]);
  const [showDoneTickets, setShowDoneTickets] = useState(false);
  const [showNoStoryPoints, setShowNoStoryPoints] = useState(false);
  // Use only configured JIRA base URL; do not fall back to a hard-coded tenant in production
  const JIRA_BASE_URL = import.meta.env.VITE_JIRA_BASE_URL || null;
  // Azure DevOps connection (optional). For security, prefer calling a server-side proxy.
  const AZDO_ORG_URL = import.meta.env.VITE_AZDO_ORG_URL || null;
  const AZDO_PAT = import.meta.env.VITE_AZDO_PAT || null;
  const [azdoGroupBy, setAzdoGroupBy] = useState('AreaPath');

  const parseAssigneeProjectMapping = (text) => {
    const lines = text.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
    if (lines.length === 0) return {};

    // split header and find relevant columns
    const separator = lines[0].includes('\t') ? '\t' : ',';
    const headerCols = lines[0].split(separator).map((h) => h.trim().toLowerCase());
    const teamIdx = headerCols.findIndex((h) => h.includes('team') || h.includes('member') || h.includes('name'));
    const projectCodeIdx = headerCols.findIndex((h) => h.includes('code'));
    const projectNameIdx = headerCols.findIndex((h) => h.includes('project') && !h.includes('code'));

    const map = {};
    for (let i = 1; i < lines.length; i++) {
      const parts = lines[i].split(separator).map((c) => c.trim());
      const name = (teamIdx >= 0 ? parts[teamIdx] : parts[0]) || '';
      const code = (projectCodeIdx >= 0 ? parts[projectCodeIdx] : '') || (projectNameIdx >= 0 ? parts[projectNameIdx] : '');
      if (!name) continue;
      const key = name.trim();
      if (!map[key]) map[key] = new Set();
      if (code) map[key].add(code.trim());
    }

    return map;
  };

  const normalizeProject = (s) => {
    if (!s) return '';
    return String(s).toLowerCase().replace(/[^a-z0-9]/g, '');
  };

  const builtinProjectKeys = useMemo(() => {
    try {
      return new Set(Object.keys(allowedAssignees || {}).map((p) => normalizeProject(p)));
    } catch (e) {
      return new Set();
    }
  }, [allowedAssignees]);

  const isBuiltinProject = (project) => {
    if (!project) return false;
    return builtinProjectKeys.has(normalizeProject(project));
  };

  const hasBuiltinRejections = useMemo(() => {
    try {
      return Array.isArray(suggestionRejections) && suggestionRejections.some((r) => isBuiltinProject(r.project));
    } catch (e) {
      return false;
    }
  }, [suggestionRejections, builtinProjectKeys]);

  const renderListPreview = (arr = [], max = 5) => {
    if (!arr || !Array.isArray(arr) || arr.length === 0) return null;
    const shown = arr.slice(0, max).join(', ');
    return arr.length > max ? <span title={arr.join(', ')}>{shown}, +{arr.length - max} more</span> : <span title={arr.join(', ')}>{shown}</span>;
  };

  const handleMappingUpload = async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    try {
      const ab = await file.arrayBuffer();
      const text = new TextDecoder('utf-8').decode(ab);
      const parsed = parseAssigneeProjectMapping(text);
      setAssigneeProjectMap(parsed);
      setMappingLoadedCount(Object.keys(parsed).length);
      try { setMappingDiagnostics(computeMappingDiagnostics()); } catch (e) {}
      try {
        const serial = {};
        Object.keys(parsed).forEach((k) => {
          serial[k] = Array.from(parsed[k] || []);
        });
        localStorage.setItem('assigneeProjectMap', JSON.stringify(serial));
      } catch (e) {}
    } catch (err) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        const parsed = parseAssigneeProjectMapping(ev.target.result);
        setAssigneeProjectMap(parsed);
        setMappingLoadedCount(Object.keys(parsed).length);
        try { setMappingDiagnostics(computeMappingDiagnostics()); } catch (e) {}
        try {
          const serial = {};
          Object.keys(parsed).forEach((k) => {
            serial[k] = Array.from(parsed[k] || []);
          });
          localStorage.setItem('assigneeProjectMap', JSON.stringify(serial));
        } catch (e) {}
      };
      reader.readAsText(file);
    }
  };

  const exportMapping = () => {
    try {
      const map = assigneeProjectMap || {};
      const rows = [];
      Object.keys(map).forEach((assignee) => {
        const projects = Array.from(map[assignee] || []);
        if (projects.length === 0) {
          rows.push([assignee, '']);
        } else {
          projects.forEach((p) => rows.push([assignee, p]));
        }
      });
      if (rows.length === 0) {
        window.alert('No mapping loaded to export');
        return;
      }
      const header = ['Assignee', 'Project'];
      const csv = [header.join(','), ...rows.map((r) => r.map((c) => `"${(c||'').toString().replace(/"/g,'""')}"`).join(','))].join('\r\n');
      const bom = '\uFEFF';
      const blob = new Blob([bom + csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'assignee-project-mapping.csv';
      a.click();
      URL.revokeObjectURL(url);
    } catch (e) {
      console.error('Export mapping failed', e);
      window.alert('Export failed');
    }
  };

  const exportDiagnostics = (rows = []) => {
    try {
      if (!rows || rows.length === 0) {
        window.alert('No diagnostics to export');
        return;
      }
      const headers = ['Issue', 'Project', 'Summary'];
      const csvRows = rows.map((r) => [r.issueKey, r.project, (r.summary || '').replace(/"/g, '""')]);
      const csv = [headers.join(','), ...csvRows.map((r) => r.map((c) => `"${(c||'').toString().replace(/"/g,'""')}"`).join(','))].join('\r\n');
      const bom = '\uFEFF';
      const blob = new Blob([bom + csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'mapping-diagnostics.csv';
      a.click();
      URL.revokeObjectURL(url);
    } catch (e) {
      console.error('Export diagnostics failed', e);
      window.alert('Export diagnostics failed');
    }
  };

  const clearMapping = () => {
    if (!window.confirm('Clear loaded mapping and forget persisted mapping?')) return;
    setAssigneeProjectMap({});
    setMappingLoadedCount(0);
    try {
      localStorage.removeItem('assigneeProjectMap');
    } catch (e) {}
    setMappingDiagnostics([]);
    setShowMappingDiagnostics(false);
  };

  const computeMappingDiagnostics = () => {
    const diagnostics = [];
    const map = assigneeProjectMap || {};
    if (!map || Object.keys(map).length === 0) return diagnostics;
    filteredData.forEach((item) => {
      const project = item['Project'] || item.Project || item['Project key'] || item['Project Key'] || '';
      const key = String(item['Issue key'] || item['Key'] || item['Issue Key'] || item.id || '');
      if (!project) return;
      const projNorm = normalizeProject(project);
      const has = Object.keys(map).some((assignee) => {
        const set = map[assignee] || new Set();
        return Array.from(set).some((p) => {
          const an = normalizeProject(p);
          return an === projNorm || an.includes(projNorm) || projNorm.includes(an);
        });
      });
      if (!has) {
        diagnostics.push({ issueKey: key, project, summary: item.Summary || item.summary || '' });
      }
    });
    return diagnostics;
  };

const quickAddMapping = (assignee, project) => {
  if (!assignee) return;
  const map = { ...(assigneeProjectMap || {}) };
  if (!map[assignee]) map[assignee] = new Set();
  map[assignee].add(project);
  setAssigneeProjectMap(map);
  setMappingLoadedCount(Object.keys(map).length);
  try {
    const serial = {};
    Object.keys(map).forEach((k) => {
      serial[k] = Array.from(map[k] || []);
    });
    localStorage.setItem('assigneeProjectMap', JSON.stringify(serial));
  } catch (e) {}
  try { setMappingDiagnostics(computeMappingDiagnostics()); } catch (e) {}
};

  // load persisted mapping on mount and merge with built-in allowedAssignees
  useEffect(() => {
    try {
      // extract merge+persist logic so it can be re-run on demand (force refresh)
      const buildAndPersistMergedMapping = () => {
        const builtin = {};
        Object.keys(allowedAssignees || {}).forEach((project) => {
          const list = allowedAssignees[project] || [];
          list.forEach((assignee) => {
            const a = (assignee || '').toString();
            if (!a) return;
            if (!builtin[a]) builtin[a] = new Set();
            builtin[a].add(project);
          });
        });

        const raw = localStorage.getItem('assigneeProjectMap');
        if (raw) {
          try {
            const parsed = JSON.parse(raw);
            Object.keys(parsed).forEach((k) => {
              const arr = parsed[k] || [];
              if (!builtin[k]) builtin[k] = new Set();
              arr.forEach((p) => builtin[k].add(p));
            });
          } catch (e) {
            // malformed persisted mapping; ignore
          }
        }

        // Persist the merged mapping back to localStorage (so built-in mapping becomes editable)
        try {
          const serial = {};
          Object.keys(builtin).forEach((k) => {
            serial[k] = Array.from(builtin[k] || []);
          });
          localStorage.setItem('assigneeProjectMap', JSON.stringify(serial));
        } catch (e) {}

        setAssigneeProjectMap(builtin);
        setMappingLoadedCount(Object.keys(builtin).length);

        // Build project->allowedAssignees map for quick lookup (plain arrays)
        const projAllowed = {};
        // Start from built-in allowedAssignees JSON
        Object.keys(allowedAssignees || {}).forEach((project) => {
          const list = allowedAssignees[project] || [];
          projAllowed[project] = Array.from(new Set([...(projAllowed[project] || []), ...list.map((s) => (s || '').toString())]));
        });
        // Merge persisted mapping (builtin contains assignee->projects)
        Object.keys(builtin).forEach((assignee) => {
          const projects = Array.from(builtin[assignee] || []);
          projects.forEach((project) => {
            // If this project has an explicit builtin allowed list, prefer that and do NOT merge uploaded mappings for it.
            if (allowedAssignees && Object.prototype.hasOwnProperty.call(allowedAssignees, project)) {
              return;
            }
            if (!projAllowed[project]) projAllowed[project] = [];
            if (!projAllowed[project].includes(assignee)) projAllowed[project].push(assignee);
          });
        });

        setProjectAllowedMap(projAllowed);
        try {
          setMappingDiagnostics(computeMappingDiagnostics());
        } catch (e) {}
      };

      // run once at mount
      buildAndPersistMergedMapping();

      // expose for manual invocation via window for debugging and forced refresh
      try {
        window.__refreshAssigneeMapping = buildAndPersistMergedMapping;
      } catch (e) {}
    } catch (e) {}
  }, []);

  // small helper: trigger a forced refresh and persist of the merged mapping
  const forceRefreshMapping = () => {
    try {
      if (window && window.__refreshAssigneeMapping) window.__refreshAssigneeMapping();
      else {
        // fallback: re-run the same logic by reloading the page so mount effect runs
        window.location.reload();
      }
    } catch (e) {
      try { window.location.reload(); } catch (err) {}
    }
  };

  const parseCSV = (text) => {
    const lines = text.split('\n').filter((line) => line.trim());
    if (lines.length === 0) return [];

    const headers = lines[0].split('\t').map((h) => h.trim());

    console.log('Headers found:', headers);
    console.log('Assignee column (D):', headers[3]);
    console.log('Sprint column (G):', headers[6]);

    const parsedData = lines.slice(1).map((line, index) => {
      const values = line.split('\t');
      const obj = {};
      headers.forEach((header, i) => {
        obj[header] = values[i]?.trim() || '';
      });

      if (index < 3) {
        console.log(
          `Row ${index + 1} - Assignee:`,
          obj[headers[3]],
          'Sprint:',
          obj[headers[6]],
        );
      }

      return obj;
    });

    // Extract sprint dates
    const dates = {};
    parsedData.forEach((item) => {
      const sprint = item['Sprint'] || item['G'] || '';
      if (sprint && !dates[sprint]) {
        const dateMatch = sprint.match(
          /(\d{2}-\d{2}-\d{2})\s+to\s+(\d{2}-\d{2}-\d{2})/,
        );
        if (dateMatch) {
          const startParts = dateMatch[1].split('-');
          const endParts = dateMatch[2].split('-');
          dates[sprint] = {
            start: `${startParts[0]}/${startParts[1]}/20${startParts[2]}`,
            end: `${endParts[0]}/${endParts[1]}/20${endParts[2]}`,
          };
        }
      }
    });

    setSprintDates(dates);
    return parsedData;
  };

  const handleGoHome = () => {
    setData([]);
    setSelectedSprint('all');
    setSelectedAssignee('all');
  };

  // Minimal UI while restoring full component body
  return (
    <div className="min-h-screen bg-slate-950 p-6 text-slate-100">
      <div>Restored baseline. Run dev server to confirm.</div>
    </div>
  );
};

export default SprintDashboard;
